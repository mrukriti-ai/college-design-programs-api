"""
Enhanced Add Function Module

This module provides a comprehensive add function with advanced error handling including:
- Type hints for better code documentation
- Comprehensive error handling for all edge cases
- Overflow protection and precision limits
- Custom exception classes
- Logging for debugging
- Input validation and sanitization
- Performance monitoring

Author: Generated by AI Assistant
Date: 2024
"""

import math
import logging
import sys
from typing import Union, List, Tuple, Optional
from decimal import Decimal, InvalidOperation, Overflow, Underflow
import time

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Custom exception classes
class AddFunctionError(Exception):
    """Base exception for add function errors"""
    pass

class OverflowError(AddFunctionError):
    """Raised when addition would cause overflow"""
    pass

class PrecisionError(AddFunctionError):
    """Raised when precision limits are exceeded"""
    pass

class InputValidationError(AddFunctionError):
    """Raised when input validation fails"""
    pass

class PerformanceWarning(AddFunctionError):
    """Warning for performance issues"""
    pass


def validate_numeric_input(value, param_name: str) -> None:
    """
    Validate that a value is a valid numeric input.
    
    Args:
        value: The value to validate
        param_name (str): Name of the parameter for error messages
        
    Raises:
        InputValidationError: If validation fails
    """
    # Check if value is None
    if value is None:
        raise InputValidationError(f"{param_name} cannot be None")
    
    # Check if value is a number
    if not isinstance(value, (int, float)):
        raise InputValidationError(f"{param_name} must be a number (int or float), got {type(value).__name__}")
    
    # Check for NaN
    if math.isnan(value):
        raise InputValidationError(f"{param_name} cannot be NaN")
    
    # Check for infinity
    if math.isinf(value):
        logger.warning(f"{param_name} is infinite: {value}")
    
    # Check for extremely large numbers that might cause overflow
    if abs(value) > 1e308:
        logger.warning(f"{param_name} is extremely large: {value}")


def check_overflow(a: Union[int, float], b: Union[int, float]) -> None:
    """
    Check if addition would cause overflow.
    
    Args:
        a: First number
        b: Second number
        
    Raises:
        OverflowError: If overflow would occur
    """
    try:
        # Use Decimal for precise overflow checking
        decimal_a = Decimal(str(a))
        decimal_b = Decimal(str(b))
        result = decimal_a + decimal_b
        
        # Check if result is finite
        if not result.is_finite():
            raise OverflowError("Addition would result in overflow")
            
    except (InvalidOperation, Overflow, Underflow) as e:
        raise OverflowError(f"Overflow detected: {e}")


def add_with_enhanced_error_handling(
    a: Union[int, float], 
    b: Union[int, float],
    max_precision: int = 15,
    enable_overflow_check: bool = True,
    enable_logging: bool = True
) -> Union[int, float]:
    """
    Add two numbers with comprehensive error handling.
    
    This function provides extensive error handling including:
    - Input validation
    - Overflow protection
    - Precision limits
    - Performance monitoring
    - Detailed logging
    
    Args:
        a (Union[int, float]): The first number to add
        b (Union[int, float]): The second number to add
        max_precision (int): Maximum decimal places allowed (default: 15)
        enable_overflow_check (bool): Enable overflow checking (default: True)
        enable_logging (bool): Enable logging (default: True)
        
    Returns:
        Union[int, float]: The sum of a and b
        
    Raises:
        InputValidationError: If input validation fails
        OverflowError: If overflow would occur
        PrecisionError: If precision limits are exceeded
        PerformanceWarning: If operation takes too long
        
    Examples:
        >>> add_with_enhanced_error_handling(5, 3)
        8
        >>> add_with_enhanced_error_handling(3.14159, 2.71828)
        5.85987
        >>> add_with_enhanced_error_handling(1e308, 1e308)
        OverflowError: Addition would result in overflow
    """
    start_time = time.time()
    
    try:
        # Input validation
        if enable_logging:
            logger.info(f"Adding numbers: {a} + {b}")
        
        validate_numeric_input(a, "First argument")
        validate_numeric_input(b, "Second argument")
        
        # Overflow checking
        if enable_overflow_check:
            check_overflow(a, b)
        
        # Handle special cases
        if math.isinf(a) or math.isinf(b):
            if math.isinf(a) and math.isinf(b):
                if a == b:  # Both positive or both negative infinity
                    if enable_logging:
                        logger.info(f"Adding infinities: {a} + {b} = {a}")
                    return a
                else:  # Positive + negative infinity
                    raise InputValidationError("Cannot add positive and negative infinity")
            else:
                result = a if math.isinf(a) else b
                if enable_logging:
                    logger.info(f"Adding infinity: {a} + {b} = {result}")
                return result
        
        # Perform addition
        result = a + b
        
        # Check precision
        if isinstance(result, float):
            # Convert to string to check decimal places
            result_str = f"{result:.{max_precision}f}".rstrip('0').rstrip('.')
            if '.' in result_str:
                decimal_places = len(result_str.split('.')[1])
                if decimal_places > max_precision:
                    raise PrecisionError(f"Result has {decimal_places} decimal places, maximum allowed is {max_precision}")
        
        # Return integer if result is whole number
        if isinstance(result, float) and result.is_integer():
            result = int(result)
        
        # Performance monitoring
        execution_time = time.time() - start_time
        if execution_time > 0.1:  # More than 100ms
            warning = PerformanceWarning(f"Addition took {execution_time:.4f} seconds")
            if enable_logging:
                logger.warning(str(warning))
            else:
                raise warning
        
        if enable_logging:
            logger.info(f"Addition completed: {a} + {b} = {result} (took {execution_time:.6f}s)")
        
        return result
        
    except Exception as e:
        if enable_logging:
            logger.error(f"Error in addition: {e}")
        raise


def add_multiple_with_error_handling(
    *args: Union[int, float],
    max_precision: int = 15,
    enable_overflow_check: bool = True,
    enable_logging: bool = True
) -> Union[int, float]:
    """
    Add multiple numbers with comprehensive error handling.
    
    Args:
        *args (Union[int, float]): Variable number of numbers to add
        max_precision (int): Maximum decimal places allowed
        enable_overflow_check (bool): Enable overflow checking
        enable_logging (bool): Enable logging
        
    Returns:
        Union[int, float]: The sum of all provided numbers
        
    Raises:
        InputValidationError: If input validation fails
        OverflowError: If overflow would occur
        PrecisionError: If precision limits are exceeded
    """
    if not args:
        raise InputValidationError("At least one number must be provided")
    
    if enable_logging:
        logger.info(f"Adding multiple numbers: {args}")
    
    # Validate all inputs
    for i, arg in enumerate(args):
        validate_numeric_input(arg, f"Argument {i+1}")
    
    # Check for multiple infinities
    infinities = [arg for arg in args if math.isinf(arg)]
    if len(infinities) > 1:
        has_positive = any(math.isinf(arg) and arg > 0 for arg in args)
        has_negative = any(math.isinf(arg) and arg < 0 for arg in args)
        if has_positive and has_negative:
            raise InputValidationError("Cannot add positive and negative infinity")
        return infinities[0]
    
    # Perform addition with error handling
    result = 0
    for arg in args:
        result = add_with_enhanced_error_handling(
            result, arg, max_precision, enable_overflow_check, enable_logging=False
        )
    
    if enable_logging:
        logger.info(f"Multiple addition completed: sum of {args} = {result}")
    
    return result


def safe_add(a: Union[int, float], b: Union[int, float]) -> Optional[Union[int, float]]:
    """
    Safe addition that returns None on error instead of raising exceptions.
    
    Args:
        a (Union[int, float]): The first number to add
        b (Union[int, float]): The second number to add
        
    Returns:
        Optional[Union[int, float]]: The sum of a and b, or None if error occurs
    """
    try:
        return add_with_enhanced_error_handling(a, b, enable_logging=False)
    except Exception as e:
        logger.error(f"Safe addition failed: {e}")
        return None


def add_with_retry(
    a: Union[int, float], 
    b: Union[int, float], 
    max_retries: int = 3,
    delay: float = 0.1
) -> Union[int, float]:
    """
    Add two numbers with retry mechanism for transient errors.
    
    Args:
        a (Union[int, float]): The first number to add
        b (Union[int, float]): The second number to add
        max_retries (int): Maximum number of retry attempts
        delay (float): Delay between retries in seconds
        
    Returns:
        Union[int, float]: The sum of a and b
        
    Raises:
        Exception: If all retry attempts fail
    """
    last_exception = None
    
    for attempt in range(max_retries + 1):
        try:
            return add_with_enhanced_error_handling(a, b, enable_logging=False)
        except Exception as e:
            last_exception = e
            if attempt < max_retries:
                logger.warning(f"Addition attempt {attempt + 1} failed: {e}. Retrying in {delay}s...")
                time.sleep(delay)
            else:
                logger.error(f"All {max_retries + 1} addition attempts failed. Last error: {e}")
    
    raise last_exception


# Example usage and demonstration
if __name__ == "__main__":
    print("🧮 Enhanced Add Function Demonstration")
    print("=" * 50)
    
    # Test cases with different error scenarios
    test_cases = [
        ("Basic addition", lambda: add_with_enhanced_error_handling(5, 3)),
        ("Float addition", lambda: add_with_enhanced_error_handling(3.14, 2.86)),
        ("Negative numbers", lambda: add_with_enhanced_error_handling(-5, 10)),
        ("Zero addition", lambda: add_with_enhanced_error_handling(0, 0)),
        ("Large numbers", lambda: add_with_enhanced_error_handling(1e15, 1e15)),
        ("Safe addition", lambda: safe_add(5, 3)),
        ("Multiple addition", lambda: add_multiple_with_error_handling(1, 2, 3, 4, 5)),
    ]
    
    for test_name, test_func in test_cases:
        try:
            result = test_func()
            print(f"✅ {test_name}: {result}")
        except Exception as e:
            print(f"❌ {test_name}: {type(e).__name__}: {e}")
    
    print("\n" + "=" * 50)
    print("Error Handling Examples:")
    
    # Error test cases
    error_cases = [
        ("None input", lambda: add_with_enhanced_error_handling(None, 5)),
        ("String input", lambda: add_with_enhanced_error_handling("5", 3)),
        ("NaN input", lambda: add_with_enhanced_error_handling(float('nan'), 5)),
        ("Empty multiple", lambda: add_multiple_with_error_handling()),
        ("Safe addition with error", lambda: safe_add("5", 3)),
    ]
    
    for error_name, error_func in error_cases:
        try:
            result = error_func()
            print(f"⚠️  {error_name}: Unexpected success - {result}")
        except Exception as e:
            print(f"✅ {error_name}: {type(e).__name__}: {e}")
    
    print("\n✅ Enhanced add function demonstration completed!") 